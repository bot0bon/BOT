import { AnchorProvider, Program } from "@coral-xyz/anchor";
import { PumpAmmAdminSdk, PumpAmmSdk } from "@pump-fun/pump-swap-sdk";
import {
  createAssociatedTokenAccountIdempotentInstruction,
  getAssociatedTokenAddressSync,
  NATIVE_MINT,
  TOKEN_PROGRAM_ID,
} from "@solana/spl-token";
import {
  AccountInfo,
  Connection,
  PublicKey,
  PublicKeyInitData,
  TransactionInstruction,
} from "@solana/web3.js";
import pumpIdl from "./idl/pump.json";
import { Pump } from "./idl/pump";
import BN from "bn.js";

import {
  bondingCurvePda,
  canonicalPumpPoolPda,
  creatorVaultPda,
  globalPda,
  pumpPoolAuthorityPda,
} from "./pda";
import { BondingCurve, Global } from "./state";

export function getPumpProgram(
  connection: Connection,
  programId: PublicKey,
): Program<Pump> {
  const pumpIdlAddressOverride = { ...pumpIdl };

  pumpIdlAddressOverride.address = programId.toString();

  return new Program(
    pumpIdlAddressOverride as Pump,
    new AnchorProvider(connection, null as any, {}),
  );
}

export const PUMP_PROGRAM_ID = new PublicKey(
  "6EF8rrecthR5Dkzon8Nwu78hRvfCKubJ14M5uBEwF6P",
);
export const PUMP_AMM_PROGRAM_ID = new PublicKey(
  "pAMMBay6oceH9fJKBRHGP5D4bD4sWpmSwMn52FMfXEA",
);

export const BONDING_CURVE_NEW_SIZE = 150;

export class PumpSdk {
  private readonly connection: Connection;
  private readonly pumpProgram: Program<Pump>;
  private readonly offlinePumpProgram: Program<Pump>;
  private readonly pumpAmmSdk: PumpAmmSdk;
  private readonly pumpAmmAdminSdk: PumpAmmAdminSdk;

  constructor(
    connection: Connection,
    pumpProgramId: PublicKey = PUMP_PROGRAM_ID,
    pumpAmmProgramId: PublicKey = PUMP_AMM_PROGRAM_ID,
  ) {
    this.connection = connection;

    this.pumpProgram = getPumpProgram(connection, pumpProgramId);
    this.offlinePumpProgram = getPumpProgram(
      null as any as Connection,
      pumpProgramId,
    );

    this.pumpAmmSdk = new PumpAmmSdk(connection, pumpAmmProgramId.toBase58());
    this.pumpAmmAdminSdk = new PumpAmmAdminSdk(
      connection,
      pumpAmmProgramId.toBase58(),
    );
  }

  programId(): PublicKey {
    return this.offlinePumpProgram.programId;
  }

  globalPda() {
    return globalPda(this.offlinePumpProgram.programId);
  }

  bondingCurvePda(mint: PublicKeyInitData): PublicKey {
    return bondingCurvePda(this.offlinePumpProgram.programId, mint);
  }

  creatorVaultPda(creator: PublicKey) {
    return creatorVaultPda(this.offlinePumpProgram.programId, creator);
  }

  pumpPoolAuthorityPda(mint: PublicKey): [PublicKey, number] {
    return pumpPoolAuthorityPda(mint, this.offlinePumpProgram.programId);
  }

  canonicalPumpPoolPda(mint: PublicKey): [PublicKey, number] {
    return canonicalPumpPoolPda(
      this.offlinePumpProgram.programId,
      this.pumpAmmSdk.programId(),
      mint,
    );
  }

  decodeGlobal(accountInfo: AccountInfo<Buffer>): Global {
    return this.offlinePumpProgram.coder.accounts.decode<Global>(
      "global",
      accountInfo.data,
    );
  }

  decodeBondingCurve(accountInfo: AccountInfo<Buffer>): BondingCurve {
    return this.offlinePumpProgram.coder.accounts.decode<BondingCurve>(
      "bondingCurve",
      accountInfo.data,
    );
  }

  async fetchGlobal(): Promise<Global> {
    return await this.pumpProgram.account.global.fetch(this.globalPda());
  }

  async fetchBondingCurve(mint: PublicKeyInitData): Promise<BondingCurve> {
    return await this.pumpProgram.account.bondingCurve.fetch(
      this.bondingCurvePda(mint),
    );
  }

  async fetchBuyState(mint: PublicKey, user: PublicKey) {
    const [bondingCurveAccountInfo, associatedUserAccountInfo] =
      await this.connection.getMultipleAccountsInfo([
        this.bondingCurvePda(mint),
        getAssociatedTokenAddressSync(mint, user, true),
      ]);

    if (!bondingCurveAccountInfo) {
      throw new Error(
        `Bonding curve account not found for mint: ${mint.toBase58()}`,
      );
    }

    const bondingCurve = this.decodeBondingCurve(bondingCurveAccountInfo);
    return { bondingCurveAccountInfo, bondingCurve, associatedUserAccountInfo };
  }

  async fetchSellState(mint: PublicKey, user: PublicKey) {
    const [bondingCurveAccountInfo, associatedUserAccountInfo] =
      await this.connection.getMultipleAccountsInfo([
        this.bondingCurvePda(mint),
        getAssociatedTokenAddressSync(mint, user, true),
      ]);

    if (!bondingCurveAccountInfo) {
      throw new Error(
        `Bonding curve account not found for mint: ${mint.toBase58()}`,
      );
    }

    if (!associatedUserAccountInfo) {
      throw new Error(
        `Associated token account not found for mint: ${mint.toBase58()} and user: ${user.toBase58()}`,
      );
    }

    const bondingCurve = this.decodeBondingCurve(bondingCurveAccountInfo);
    return { bondingCurveAccountInfo, bondingCurve };
  }

  async createInstruction({
    mint,
    name,
    symbol,
    uri,
    creator,
    user,
  }: {
    mint: PublicKey;
    name: string;
    symbol: string;
    uri: string;
    creator: PublicKey;
    user: PublicKey;
  }): Promise<TransactionInstruction> {
    return await this.offlinePumpProgram.methods
      .create(name, symbol, uri, creator)
      .accountsPartial({
        mint,
        user,
      })
      .instruction();
  }

  async buyInstructions({
    global,
    bondingCurveAccountInfo,
    bondingCurve,
    associatedUserAccountInfo,
    mint,
    user,
    amount,
    solAmount,
    slippage,
  }: {
    global: Global;
    bondingCurveAccountInfo: AccountInfo<Buffer>;
    bondingCurve: BondingCurve;
    associatedUserAccountInfo: AccountInfo<Buffer> | null;
    mint: PublicKey;
    user: PublicKey;
    amount: BN;
    solAmount: BN;
    slippage: number;
  }): Promise<TransactionInstruction[]> {
    const instructions: TransactionInstruction[] = [];

    if (bondingCurveAccountInfo.data.length < BONDING_CURVE_NEW_SIZE) {
      instructions.push(
        await this.extendAccountInstruction({
          account: this.bondingCurvePda(mint),
          user,
        }),
      );
    }

    const associatedUser = getAssociatedTokenAddressSync(mint, user, true);

    if (!associatedUserAccountInfo) {
      instructions.push(
        createAssociatedTokenAccountIdempotentInstruction(
          user,
          associatedUser,
          user,
          mint,
        ),
      );
    }

    instructions.push(
      await this.buyInstruction({
        global,
        mint,
        creator: bondingCurve.creator,
        user,
        associatedUser,
        amount,
        solAmount,
        slippage,
      }),
    );

    return instructions;
  }

  async createAndBuyInstructions({
    global,
    mint,
    name,
    symbol,
    uri,
    creator,
    user,
    amount,
    solAmount,
  }: {
    global: Global;
    mint: PublicKey;
    name: string;
    symbol: string;
    uri: string;
    creator: PublicKey;
    user: PublicKey;
    amount: BN;
    solAmount: BN;
  }): Promise<TransactionInstruction[]> {
    const associatedUser = getAssociatedTokenAddressSync(mint, user, true);
    return [
      await this.createInstruction({ mint, name, symbol, uri, creator, user }),
      await this.extendAccountInstruction({
        account: this.bondingCurvePda(mint),
        user,
      }),
      createAssociatedTokenAccountIdempotentInstruction(
        user,
        associatedUser,
        user,
        mint,
      ),
      await this.buyInstruction({
        global,
        mint,
        creator,
        user,
        associatedUser,
        amount,
        solAmount,
        slippage: 1,
      }),
    ];
  }

  private async buyInstruction({
    global,
    mint,
    creator,
    user,
    associatedUser,
    amount,
    solAmount,
    slippage,
  }: {
    global: Global;
    mint: PublicKey;
    creator: PublicKey;
    user: PublicKey;
    associatedUser: PublicKey;
    amount: BN;
    solAmount: BN;
    slippage: number;
  }) {
    return await this.offlinePumpProgram.methods
      .buy(
        amount,
        solAmount.add(
          solAmount.mul(new BN(Math.floor(slippage * 10))).div(new BN(1000)),
        ),
      )
      .accountsPartial({
        feeRecipient: getFeeRecipient(global),
        mint,
        associatedUser,
        user,
        creatorVault: this.creatorVaultPda(creator),
      })
      .instruction();
  }

  async sellInstructions({
    global,
    bondingCurveAccountInfo,
    bondingCurve,
    mint,
    user,
    amount,
    solAmount,
    slippage,
  }: {
    global: Global;
    bondingCurveAccountInfo: AccountInfo<Buffer>;
    bondingCurve: BondingCurve;
    mint: PublicKey;
    user: PublicKey;
    amount: BN;
    solAmount: BN;
    slippage: number;
  }): Promise<TransactionInstruction[]> {
    const instructions: TransactionInstruction[] = [];

    if (bondingCurveAccountInfo.data.length < BONDING_CURVE_NEW_SIZE) {
      instructions.push(
        await this.extendAccountInstruction({
          account: this.bondingCurvePda(mint),
          user,
        }),
      );
    }

    instructions.push(
      await this.offlinePumpProgram.methods
        .sell(
          amount,
          solAmount.sub(
            solAmount.mul(new BN(Math.floor(slippage * 10))).div(new BN(1000)),
          ),
        )
        .accountsPartial({
          feeRecipient: getFeeRecipient(global),
          mint,
          associatedUser: getAssociatedTokenAddressSync(mint, user, true),
          user,
          creatorVault: this.creatorVaultPda(bondingCurve.creator),
        })
        .instruction(),
    );

    return instructions;
  }

  async extendAccountInstruction({
    account,
    user,
  }: {
    account: PublicKey;
    user: PublicKey;
  }): Promise<TransactionInstruction> {
    return this.offlinePumpProgram.methods
      .extendAccount()
      .accountsPartial({
        account,
        user,
      })
      .instruction();
  }

  async migrateInstruction({
    global,
    mint,
    user,
  }: {
    global: Global;
    mint: PublicKey;
    user: PublicKey;
  }): Promise<TransactionInstruction> {
    return this.offlinePumpProgram.methods
      .migrate()
      .accountsPartial({
        mint,
        user,
        pumpAmm: this.pumpAmmSdk.programId(),
        withdrawAuthority: global.withdrawAuthority,
      })
      .instruction();
  }

  async collectCoinCreatorFeeInstructions(
    coinCreator: PublicKey,
  ): Promise<TransactionInstruction[]> {
    let quoteMint = NATIVE_MINT;
    let quoteTokenProgram = TOKEN_PROGRAM_ID;

    let coinCreatorVaultAuthority =
      this.pumpAmmSdk.coinCreatorVaultAuthorityPda(coinCreator);
    let coinCreatorVaultAta = this.pumpAmmSdk.coinCreatorVaultAta(
      coinCreatorVaultAuthority,
      quoteMint,
      quoteTokenProgram,
    );

    let coinCreatorTokenAccount = getAssociatedTokenAddressSync(
      quoteMint,
      coinCreator,
      true,
      quoteTokenProgram,
    );
    const [coinCreatorVaultAtaAccountInfo, coinCreatorTokenAccountInfo] =
      await this.connection.getMultipleAccountsInfo([
        coinCreatorVaultAta,
        coinCreatorTokenAccount,
      ]);

    return [
      await this.offlinePumpProgram.methods
        .collectCreatorFee()
        .accountsPartial({
          creator: coinCreator,
        })
        .instruction(),
      ...(await this.pumpAmmSdk.collectCoinCreatorFee({
        coinCreator,
        quoteMint,
        quoteTokenProgram,
        coinCreatorVaultAuthority,
        coinCreatorVaultAta,
        coinCreatorTokenAccount,
        coinCreatorVaultAtaAccountInfo,
        coinCreatorTokenAccountInfo,
      })),
    ];
  }

  async adminSetCoinCreatorInstructions(
    newCoinCreator: PublicKey,
    mint: PublicKey,
  ): Promise<TransactionInstruction[]> {
    const global = await this.fetchGlobal();

    return [
      await this.offlinePumpProgram.methods
        .adminSetCreator(newCoinCreator)
        .accountsPartial({
          adminSetCreatorAuthority: global.adminSetCreatorAuthority,
          mint,
        })
        .instruction(),
      await this.pumpAmmAdminSdk.adminSetCoinCreator(mint, newCoinCreator),
    ];
  }

  async getCreatorVaultBalance(creator: PublicKey): Promise<BN> {
    const creatorVault = this.creatorVaultPda(creator);
    const accountInfo = await this.connection.getAccountInfo(creatorVault);

    if (accountInfo === null) {
      return new BN(0);
    }

    const rentExemptionLamports =
      await this.connection.getMinimumBalanceForRentExemption(
        accountInfo.data.length,
      );

    if (accountInfo.lamports < rentExemptionLamports) {
      return new BN(0);
    }

    return new BN(accountInfo.lamports - rentExemptionLamports);
  }
}

function getFeeRecipient(global: Global): PublicKey {
  const feeRecipients = [global.feeRecipient, ...global.feeRecipients];
  return feeRecipients[Math.floor(Math.random() * feeRecipients.length)];
}
